using Microsoft.Extensions.Logging;
using OpenChat.Core.Logging;
using OpenChat.Core.Models;
using OpenChat.Core.Marmot;

namespace OpenChat.Core.Services;

public class MlsService : IMlsService
{
    private readonly ILogger<MlsService> _logger;
    private MarmotWrapper? _marmotClient;
    private string? _privateKeyHex;
    private string? _publicKeyHex;

    public MlsService()
    {
        _logger = LoggingConfiguration.CreateLogger<MlsService>();
        _logger.LogDebug("MlsService instance created");
    }

    public async Task InitializeAsync(string privateKeyHex, string publicKeyHex)
    {
        _logger.LogInformation("Initializing MLS service");
        _privateKeyHex = privateKeyHex;
        _publicKeyHex = publicKeyHex;

        // Initialize the Marmot FFI client
        _marmotClient = new MarmotWrapper();
        await _marmotClient.InitializeAsync(privateKeyHex, publicKeyHex);
        _logger.LogInformation("MLS service initialized successfully");
    }

    public async Task<KeyPackage> GenerateKeyPackageAsync()
    {
        EnsureInitialized();

        var result = await _marmotClient!.GenerateKeyPackageAsync();

        // Extract actual ciphersuite from MDK-provided tags
        ushort ciphersuiteId = 0x0001; // Default
        var csTag = result.Tags.FirstOrDefault(t => t.Count >= 2 && t[0] == "mls_ciphersuite");
        if (csTag != null && csTag[1].StartsWith("0x"))
        {
            if (ushort.TryParse(csTag[1][2..], System.Globalization.NumberStyles.HexNumber, null, out var parsed))
                ciphersuiteId = parsed;
        }

        var keyPackage = KeyPackage.Create(_publicKeyHex!, result.Data, ciphersuiteId);
        keyPackage.NostrTags = result.Tags;

        _logger.LogInformation("Generated KeyPackage with {TagCount} MDK-provided tags, ciphersuite=0x{Cs:x4}, {Len} bytes",
            result.Tags.Count, ciphersuiteId, result.Data.Length);

        return keyPackage;
    }

    public async Task<MlsGroupInfo> CreateGroupAsync(string groupName)
    {
        EnsureInitialized();

        _logger.LogInformation("CreateGroup: creating MLS group '{GroupName}'", groupName);
        var (groupId, epoch) = await _marmotClient!.CreateGroupAsync(groupName);
        var groupIdHex = Convert.ToHexString(groupId).ToLowerInvariant();
        _logger.LogInformation("CreateGroup: created group {GroupId}, epoch={Epoch}",
            groupIdHex[..Math.Min(16, groupIdHex.Length)], epoch);

        return new MlsGroupInfo
        {
            GroupId = groupId,
            GroupName = groupName,
            Epoch = epoch,
            MemberPublicKeys = new List<string> { _publicKeyHex! }
        };
    }

    public async Task<MlsWelcome> AddMemberAsync(byte[] groupId, KeyPackage keyPackage)
    {
        EnsureInitialized();

        // The Rust MDK expects the full Nostr event JSON, not just the KeyPackage bytes
        if (string.IsNullOrEmpty(keyPackage.EventJson))
        {
            throw new InvalidOperationException("KeyPackage is missing the Nostr event JSON required for MLS processing");
        }

        // Pre-validate key package event before passing to native code
        try
        {
            using var doc = System.Text.Json.JsonDocument.Parse(keyPackage.EventJson);
            var root = doc.RootElement;

            // Check kind
            if (root.TryGetProperty("kind", out var kindProp) && kindProp.GetInt32() != 443)
            {
                throw new InvalidOperationException($"KeyPackage event has wrong kind: {kindProp.GetInt32()} (expected 443)");
            }

            // Check content is non-empty and reasonable
            if (root.TryGetProperty("content", out var contentProp))
            {
                var content = contentProp.GetString();
                if (string.IsNullOrEmpty(content))
                {
                    throw new InvalidOperationException("KeyPackage event has empty content");
                }

                var contentBytes = Convert.FromBase64String(content);
                if (contentBytes.Length < 64)
                {
                    throw new InvalidOperationException(
                        $"KeyPackage content too short ({contentBytes.Length} bytes). " +
                        "This may indicate the key package was generated by a mock/test client.");
                }

                _logger.LogDebug("AddMember: KeyPackage event content is {Len} bytes (base64), " +
                    "decodes to {RawLen} bytes, owner={Owner}, event={EventId}",
                    content.Length, contentBytes.Length,
                    keyPackage.OwnerPublicKey[..Math.Min(16, keyPackage.OwnerPublicKey.Length)],
                    keyPackage.NostrEventId?[..Math.Min(16, keyPackage.NostrEventId?.Length ?? 0)] ?? "none");
            }

            // Check required tags
            if (root.TryGetProperty("tags", out var tagsProp))
            {
                bool hasEncoding = false, hasCiphersuite = false;
                foreach (var tag in tagsProp.EnumerateArray())
                {
                    if (tag.GetArrayLength() < 2) continue;
                    var tagName = tag[0].GetString();
                    if (tagName == "encoding") hasEncoding = true;
                    if (tagName == "mls_ciphersuite") hasCiphersuite = true;
                }

                if (!hasEncoding)
                    _logger.LogWarning("AddMember: KeyPackage event missing 'encoding' tag (required by MIP-00)");
                if (!hasCiphersuite)
                    _logger.LogWarning("AddMember: KeyPackage event missing 'mls_ciphersuite' tag (required by MIP-00)");
            }
        }
        catch (InvalidOperationException)
        {
            throw; // Re-throw our validation errors
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "AddMember: Failed to pre-validate KeyPackage event JSON, proceeding anyway");
        }

        var eventJsonBytes = System.Text.Encoding.UTF8.GetBytes(keyPackage.EventJson);
        var result = await _marmotClient!.AddMemberAsync(groupId, eventJsonBytes);

        return new MlsWelcome
        {
            WelcomeData = result.WelcomeData ?? Array.Empty<byte>(),
            CommitData = result.CommitData,
            RecipientPublicKey = keyPackage.OwnerPublicKey,
            KeyPackageEventId = keyPackage.NostrEventId
        };
    }

    public async Task<MlsGroupInfo> ProcessWelcomeAsync(byte[] welcomeData, string wrapperEventId)
    {
        EnsureInitialized();

        _logger.LogInformation("ProcessWelcomeAsync: wrapperEventId={EventId}, welcomeData={Len} bytes",
            wrapperEventId[..Math.Min(16, wrapperEventId.Length)], welcomeData.Length);

        var (groupId, groupName, epoch, members) = await _marmotClient!.ProcessWelcomeAsync(welcomeData, wrapperEventId);

        return new MlsGroupInfo
        {
            GroupId = groupId,
            GroupName = groupName,
            Epoch = epoch,
            MemberPublicKeys = members
        };
    }

    public async Task<byte[]> EncryptMessageAsync(byte[] groupId, string plaintext)
    {
        EnsureInitialized();

        var groupIdHex = Convert.ToHexString(groupId).ToLowerInvariant();
        _logger.LogDebug("EncryptMessage: group={GroupId}, plaintext length={Len}",
            groupIdHex[..Math.Min(16, groupIdHex.Length)], plaintext.Length);
        var result = await _marmotClient!.EncryptMessageAsync(groupId, plaintext);
        _logger.LogDebug("EncryptMessage: produced {Len} bytes ciphertext", result.Length);
        return result;
    }

    public async Task<MlsDecryptedMessage> DecryptMessageAsync(byte[] groupId, byte[] ciphertext)
    {
        EnsureInitialized();

        var groupIdHex = Convert.ToHexString(groupId).ToLowerInvariant();
        _logger.LogDebug("DecryptMessage: group={GroupId}, ciphertext={Len} bytes",
            groupIdHex[..Math.Min(16, groupIdHex.Length)], ciphertext.Length);

        var (senderPublicKey, plaintext, epoch) = await _marmotClient!.DecryptMessageAsync(groupId, ciphertext);
        _logger.LogDebug("DecryptMessage: sender={Sender}, epoch={Epoch}, plaintext length={Len}",
            senderPublicKey[..Math.Min(16, senderPublicKey.Length)], epoch, plaintext.Length);

        return new MlsDecryptedMessage
        {
            SenderPublicKey = senderPublicKey,
            Plaintext = plaintext,
            Epoch = epoch
        };
    }

    public async Task ProcessCommitAsync(byte[] groupId, byte[] commitData)
    {
        EnsureInitialized();

        var groupIdHex = Convert.ToHexString(groupId).ToLowerInvariant();
        _logger.LogInformation("ProcessCommit: group={GroupId}, commit={Len} bytes",
            groupIdHex[..Math.Min(16, groupIdHex.Length)], commitData.Length);
        await _marmotClient!.ProcessCommitAsync(groupId, commitData);
        _logger.LogInformation("ProcessCommit: success for group {GroupId}", groupIdHex[..Math.Min(16, groupIdHex.Length)]);
    }

    public async Task<byte[]> UpdateKeysAsync(byte[] groupId)
    {
        EnsureInitialized();

        return await _marmotClient!.UpdateKeysAsync(groupId);
    }

    public async Task<byte[]> RemoveMemberAsync(byte[] groupId, string memberPublicKey)
    {
        EnsureInitialized();

        return await _marmotClient!.RemoveMemberAsync(groupId, memberPublicKey);
    }

    public async Task<MlsGroupInfo?> GetGroupInfoAsync(byte[] groupId)
    {
        EnsureInitialized();

        var info = await _marmotClient!.GetGroupInfoAsync(groupId);
        if (info == null) return null;

        return new MlsGroupInfo
        {
            GroupId = info.Value.groupId,
            GroupName = info.Value.groupName,
            Epoch = info.Value.epoch,
            MemberPublicKeys = info.Value.members
        };
    }

    public async Task<byte[]> ExportGroupStateAsync(byte[] groupId)
    {
        EnsureInitialized();

        return await _marmotClient!.ExportGroupStateAsync(groupId);
    }

    public async Task ImportGroupStateAsync(byte[] groupId, byte[] state)
    {
        EnsureInitialized();

        await _marmotClient!.ImportGroupStateAsync(groupId, state);
    }

    public Task<byte[]?> ExportServiceStateAsync() => Task.FromResult<byte[]?>(null);

    public Task ImportServiceStateAsync(byte[] state) => Task.CompletedTask;

    private void EnsureInitialized()
    {
        if (_marmotClient == null)
        {
            throw new InvalidOperationException("MLS service not initialized. Call InitializeAsync first.");
        }
    }
}
